<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>宏的使用与注意事项</title>
      <link href="/2023/10/21/hong-de-shi-yong-yu-zhu-yi-shi-xiang/"/>
      <url>/2023/10/21/hong-de-shi-yong-yu-zhu-yi-shi-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="宏的使用与注意事项"><a href="#宏的使用与注意事项" class="headerlink" title="宏的使用与注意事项"></a>宏的使用与注意事项</h1><p>宏是C/C++的预处理指令，用于在编译前的预处理阶段执行文本替换、条件编译等功能。宏的使用可以减少代码重复，提高代码的可维护性，以及实现一些灵活性要求。然而，宏存在一些潜在问题，这些问题往往非常难以察觉，且在编译阶段无法被检测到。更令人担忧的是，宏在一些情况下可以正常运行并返回期望的结果，但稍不慎重就可能引发难以追踪的错误。这些问题包括宏参数的副作用、宏的优先级问题、宏名冲突、宏展开的意外结果等。因此，在使用宏时，必须谨慎思考，正确书写宏定义，避免可能导致混淆和错误的宏使用，以确保代码的可读性和稳定性。</p><h1 id="宏的基本使用"><a href="#宏的基本使用" class="headerlink" title="宏的基本使用"></a>宏的基本使用</h1><h2 id="文本替换"><a href="#文本替换" class="headerlink" title="文本替换"></a>文本替换</h2><p>宏最常见的用途是进行文本替换，通过宏定义，你可以将一个标识符关联到一个文本片段，当程序中使用这个宏时，它会被替换为定义的文本。例如：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">// 定义常量#define PI 3.14159<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过上面的宏定义，语句</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">double circleArea = 3.14159 * radius * radius;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就可以写成</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">double circleArea = PI * radius * radius;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="易踩坑点"><a href="#易踩坑点" class="headerlink" title="易踩坑点"></a>易踩坑点</h3><ul><li>宏定义的常量仅会在预处理阶段对标识符进行替换，若常量中有一些运算表达式，则有可能得到错误的结果。如</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">// 定义常量#define BASE 10+10// 有如下使用情况，想要实现语句为 int A = (10 + 10) * 2;int A = BASE * 2;      // 编程时理想结果为20// 但实际执行语句是int A = 10 + (10 * 2); // 实际结果为30<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="类型替换"><a href="#类型替换" class="headerlink" title="类型替换"></a>类型替换</h2><p>通过将变量类型用宏来代替，可以使程序更容易维护和移植。这种方式允许在需要修改变量类型时只需更新宏定义，而不必手动修改多个地方的具体类型声明。如</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define ULL unsigned long long<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过上述宏定义，语句</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">unsigned long long a;unsigned long long b;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>等价于</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">ULL a;ULL b;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="易踩坑点-1"><a href="#易踩坑点-1" class="headerlink" title="易踩坑点"></a>易踩坑点</h3><ul><li>宏并不是类型定义，在试图声明多个变量时有可能发生问题。如有如下宏定义</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define ULLP unsigned long long *<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用上述宏定义声明两个变量</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">ULLP a,b;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>实际执行结果是</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">unsigned long long * a,b;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>即变量a的类型为指针变量，而b的类型为无符号长整形变量，等价于</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">unsigned long long * a;unsigned long long b;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h3><ul><li>不要使用宏来替换类型，而是使用<code>typedef</code>或者<code>using</code>（C++）进行类型定义。如</li></ul><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">// 类型定义typedef unsigned long long * ULLP1;using ULLP2 = unsigned long long *;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用上述定义的类型声明变量， 其变量类型都为无符号长整形指针变量</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">ULLP1 a,b;ULLP2 c,b;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><p>宏常用于条件编译，以根据不同的编译选项包含或排除代码块。同时也可以方式头文件的重复引用。例如</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">// 如果定义了DEBUG宏，则程序包含调试代码，否则跳过编译#ifdef DEBUG// 调试代码#endif// 防止头文件重复引用#ifndef _HEADER_H#define _HEADER_H#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="字符串化操作符"><a href="#字符串化操作符" class="headerlink" title="字符串化操作符"></a>字符串化操作符</h2><p> <code>#</code> 操作符用于将宏参数转化为字符串。这对于将变量名转化为字符串常量非常有用。例如</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define STRINGIZE(x) #xchar* varName = STRINGIZE(variable); // 转化为 "variable"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="连接操作符"><a href="#连接操作符" class="headerlink" title="连接操作符"></a>连接操作符</h2><p><code>##</code> 操作符用于将两个宏参数连接在一起，创建一个新的标识符。这对于动态生成标识符和名称很有用。例如</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define CONCAT(a, b) a##bint result = CONCAT(x, y); // 创建一个新标识符 "xy"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="带参数的宏"><a href="#带参数的宏" class="headerlink" title="带参数的宏"></a>带参数的宏</h2><p>宏可以接受参数，使其更加通用，从表面上看其行为与函数非常相似，但注意宏并不是函数。例如</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define abs(x) (((x)&gt;=0)?(x):-(x))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>实现了一个类似abs()函数的带参数的宏，且使用方法与函数调用相同</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">abs(x);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是它并不是函数调用，而是在编译时期进行符号替换，即实际代码是</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">(((x)&gt;=0)?(x):-(x));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="易踩坑点-2"><a href="#易踩坑点-2" class="headerlink" title="易踩坑点"></a>易踩坑点</h3><ul><li>带参数的宏中宏名与括号中间不能有空格。例如</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define abs (x) (((x)&gt;=0)?(x):-(x))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>实际是定义了一个abs宏其会在编译时期，将所有的abs替换为</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">(x) (((x)&gt;=0)?(x):-(x))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>传入宏的参数为一个表达式时，会产生一些问题。例如</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define abs(x) x&gt;=0?x:-x<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>则使用时若x为一个表达式，则有可能会获得错误的结果</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">abs(a+b);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>实际展开后的结果为</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">a+b&gt;=0?a+b:-a+b;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这种情况下若<code>a+b&gt;=0</code>则会或则正确的结果，但是若<code>a+b&lt;0</code>则得到的结果为<code>-a+b</code>，而正确的结果应该为<code>-(a+b)</code>。因此，在宏定义中最好把每个参数都用括号括起来，以确保正确的参数解析和避免潜在的问题。</p><ul><li>宏用于一个更大的表达式时，会产生一些问题。例如</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define abs(x) (x)&gt;=0?(x):-(x)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当有如下使用场景</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">abs(x)+1;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>实际展开后的结果为</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">x&gt;=0?x:-x+1;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这种情况下若<code>x&lt;0</code>则会或则正确的结果，但是若<code>x&gt;=0</code>则得到的结果为<code>x</code>，而正确的结果应该为<code>x+1</code>。因此，对于宏整个结果表达式也应该用括号括起来。</p><ul><li>当传入宏的参数值会随调用的次数改变时，会产生一些问题。例如</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define abs(x) (x)&gt;=0?(x):-(x)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当有如下使用场景</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">abs(++x);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>实际展开后的结果为</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">++x &gt;= 0 ? ++x : -(++x);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这种情况下对x进行了两次的自增操作，若<code>x&gt;=0</code>，其实际得到的结果为<code>x+2</code>；若<code>x&lt;0</code>，其实际得到的结果为<code>-(x+2)</code> ，得出的都为错误的结果。</p><h3 id="使用建议-1"><a href="#使用建议-1" class="headerlink" title="使用建议"></a>使用建议</h3><ul><li>注意宏名与括号中间是否有空格。</li><li>把每个参数都用括号括起来。</li><li>整个结果表达式也应该用括号括起来。</li><li>可以使用<code>inline</code>函数替换。<code>inline</code>声明的函数，编译器会对其进行参数类型检查。<ul><li><code>inline</code>修饰的函数，在编译时会在调用内联函数的地方展开，没有函数压栈的开销。与带参数的宏的功能相同，但是比其更加安全。</li><li><code>inline</code>只是对编译器的一个建议，编译器可以选择是否进行优化。</li><li><code>inline</code>必须和函数定义放在一起才起作用。</li><li>可以将<code>inline</code>函数在头文件中定义，通常配合<code>static</code>进行使用。例如</li></ul></li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">static inline void test() {    ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>使用static关键字的作用是将函数的链接性限定为内部，使其仅在当前文件内可见，从而有效地防止与其他文件定义的同名函数发生命名冲突。</p></blockquote><h2 id="减少重复代码"><a href="#减少重复代码" class="headerlink" title="减少重复代码"></a>减少重复代码</h2><p>在编程过程中，经常会遇到需要实现一系列相似但重复的函数。这些函数通常具有高度的重复性和规律性。为了减少代码输入，提高代码的可维护性，可以使用宏来生成这些函数，从而减少编写重复代码的工作量。例如</p><p>在C程序中由于没有C++的模板函数功能，针对同一功能函数，不同的参数类型，我们需要定义多个相似的函数</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int_type get_int(int_type src){    ...    return int_xxx;}double_type get_double(double_type src){    ...    return double_xxx;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以定义如下宏</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define get_xxx(type)\type##_type get_##type(type##_type src){\...\    return type##_xxx;\}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>则上述程序的定义就可以简化为</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">get_xxx(int)get_xxx(double)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p><code>\</code>加入宏定义的行末尾，指示后面一行依然是宏的内容。</p></blockquote><h1 id="宏使用过程中其他的注意事项"><a href="#宏使用过程中其他的注意事项" class="headerlink" title="宏使用过程中其他的注意事项"></a>宏使用过程中其他的注意事项</h1><h2 id="宏并不是语句"><a href="#宏并不是语句" class="headerlink" title="宏并不是语句"></a>宏并不是语句</h2><p>在一些特殊结构中（如分支结构），宏有可能和这些结构产生一些奇妙的”化学反应“。假设有如下宏定义</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define printf_error(x) if(x&gt;0) printf("xxxx")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>并且有如下使用场景</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">if(...)    printf_error(x);else    printf_error(y);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>则实际的展开为</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">if(...)    if(x&gt;0) printf("xxxx");else    if(y&gt;0) printf("xxxx");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>根据if-else结合规则，实际代码等价于</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">if(...){    if(x&gt;0) {        printf("xxxx");    }     else{        if(y&gt;0) {            printf("xxxx");        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种隐式的错误极难发现，且不好追踪修复。</p><h2 id="使用建议-2"><a href="#使用建议-2" class="headerlink" title="使用建议"></a>使用建议</h2><ul><li>将if语句使用<code>?:</code>运算符或者<code>||</code>运算替换。</li><li>使用<code>do{}while(0)</code>包含定义,使之称为一个完整的语句。</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define printf_error(x) do{if(x&gt;0) printf("xxxx");}while(0);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 工作学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 编程问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>struct字节对齐与使用问题</title>
      <link href="/2023/10/13/struct-zi-jie-dui-qi-yu-shi-yong-wen-ti/"/>
      <url>/2023/10/13/struct-zi-jie-dui-qi-yu-shi-yong-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="stuct字节对齐"><a href="#stuct字节对齐" class="headerlink" title="stuct字节对齐"></a><code>stuct</code>字节对齐</h1><p>在C和C++中，<code>struct</code>的成员在内存中的排序方式受到字节对齐的影响，<code>struct</code>的字节对齐通常以结构体的成员中具有最大对齐需求的成员为基准。例如，如果一个<code>struct</code>中包含<code>int</code>和<code>char</code>类型的成员，那么由于<code>int</code>的字节对齐需求通常较大，因此整个结构体将按照<code>int</code>的字节大小进行字节对齐。</p><h2 id="字节对齐规则"><a href="#字节对齐规则" class="headerlink" title="字节对齐规则"></a>字节对齐规则</h2><ol><li>结构体第一个成员的偏移量为0。</li><li>结构体其他成员的偏移量为该成员大小与对齐值中较小的那个的整数倍。若成员为结构体类型，则按照结构体中最大成员大小与对齐值进行比较。</li><li>结构体的总大小为对齐值的整数倍。</li></ol><blockquote><p>对齐值默认为结构体成员中最大的那个，当然也可以通过伪指令或attribute关键字手动设置（优先级高）。</p></blockquote><h2 id="验证实验"><a href="#验证实验" class="headerlink" title="验证实验"></a>验证实验</h2><p>通过具体的实验验证这一特性：</p><ol><li>假设由如下三个结构体：</li></ol><pre class="line-numbers language-C" data-language="C"><code class="language-C">struct struct_1 {    uint8_t a;   // uint8_t占用一个字节    uint16_t b;  // uint16_t占用两个字节    uint32_t c;  // uint32_t占用四个字节};struct struct_2 {    uint16_t a;    uint16_t b;    uint32_t c;};struct struct_3 {    uint16_t a;    uint32_t b;    uint16_t c;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>分别输出三个结构体占用字节数</li></ol><pre class="line-numbers language-C" data-language="C"><code class="language-C">printf("struct_1 size: %d\n", sizeof(struct struct_1));  // struct_1 size: 8printf("struct_2 size: %d\n", sizeof(struct struct_2));  // struct_2 size: 8printf("struct_3 size: %d\n", sizeof(struct struct_3));  // struct_3 size: 12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>受到字节对齐的影响，结构体中成员的类型与顺序都会影响到最终整个结构体占用的内存大小。</p><ol start="3"><li>结构体在内存中实际的分布</li></ol><p><img src="https://cdn.jsdelivr.net/gh/lyc18/Picture-bed@main/img/202310132212579.png" alt="image.drawio"></p><ul><li><code>struct1</code>中<code>uint32_t</code>的字节最大，因此<code>struct1</code>以4字节对齐。</li><li><code>uint8_t</code> 占用1个字节，且为结构体中的第一个成员，因此偏移量为0.</li><li><code>uint16_t </code> 占用2个字节，比对齐值小，因此<code>uint16_t</code>成员的偏移量为2的整数倍，在此处偏移量为2。</li><li><code>uint32_t</code>大小为4字节，与对齐值相同，因此<code>uint16_t</code>成员的偏移量为4的整数倍，在此处偏移量为4。</li><li><code>struct2</code>与<code>struct3</code>同理。</li></ul><h1 id="struct字节对齐引发的问题"><a href="#struct字节对齐引发的问题" class="headerlink" title="struct字节对齐引发的问题"></a><code>struct</code>字节对齐引发的问题</h1><ul><li>不合理的成员顺序，可能会造成大量的内存空间浪费。</li><li>若使用内存拷贝对结构体进行赋值，若结构体内存不是紧凑的，即有部分填充字节，则可能无法获得正确的拷贝结果。<ul><li>如<code>sturct1</code>中想要赋值的结果为<code>a = 0x00, b = 0x0102, c = 0x03040506</code>，而实际结果为<code>a = 0x00, b = 0x0203, c = 0x04050607</code>。</li></ul></li><li>注意同一内存块中的不同的成员变量并不一定是紧凑的顺序。（参考<code>struct1</code>的内存分布情况）</li><li>使用内存拷贝的方式赋值时，需要注意大小端存储的问题。<ul><li>如<code>struct1</code>中从内存角度上看为<code>a = 0x00, b = 0x0203, c = 0x04050607</code>，而若在程序中使用<code>printf</code>输出的结果可能为<code>a = 0x00, b = 0x0302, c = 0x07060504</code>。</li></ul></li></ul><h2 id="验证实验-1"><a href="#验证实验-1" class="headerlink" title="验证实验"></a>验证实验</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">uint8_t data[] = {0x00, 0x01,0x02, 0x03, 0x04, 0x05, 0x06 , 0x07, 0x08, 0x09, 0x0A, 0x0B};struct_1 s1;memcpy(&amp;s1, data, sizeof(struct_1));printf("struct1 uint8_t address: 0x%x\n",(void*)(&amp;(s1.a)));  // struct1 uint8_t address: 0xc87ff62cprintf("struct1 uint16_t address: 0x%x\n",(void*)(&amp;(s1.b))); // struct1 uint16_t address: 0xc87ff62eprintf("struct1 uint32_t address: 0x%x\n",(void*)(&amp;(s1.c))); // struct1 uint32_t address: 0xc87ff630printf("struct1 uint8_t value: 0x%0.2x\n",s1.a);  // struct1 uint8_t value: 0x00printf("struct1 uint16_t value: 0x%0.4x\n",s1.b); // struct1 uint16_t value: 0x0302printf("struct1 uint32_t value: 0x%0.8x\n",s1.c); // struct1 uint32_t value: 0x07060504<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="struct字节对齐的优势"><a href="#struct字节对齐的优势" class="headerlink" title="struct字节对齐的优势"></a><code>struct</code>字节对齐的优势</h1><ul><li>两个同类型的结构体变量可以直接赋值。</li><li>提高访问速度。</li><li>减少内存浪费。</li></ul><h1 id="手动设置字节对齐值"><a href="#手动设置字节对齐值" class="headerlink" title="手动设置字节对齐值"></a>手动设置字节对齐值</h1><h2 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h2><ul><li>使用伪指令<code>#pragma pack(n)</code>，C编译器将按照n个字节对齐。</li><li>使用伪指令<code>#pragma pack()</code>,C编译器将取消自定义字节对齐方式。</li></ul><blockquote><p>此方法会影响到后续的字节对齐值。</p></blockquote><h3 id="验证实验-2"><a href="#验证实验-2" class="headerlink" title="验证实验"></a>验证实验</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">struct struct_4 {        uint8_t a;        uint16_t b;        uint32_t c;    };#pragma pack(1)struct struct_5 {    uint8_t a;    uint16_t b;    uint32_t c;};struct struct_6 {    uint8_t a;    uint16_t b;    uint32_t c;};#pragma pack(8)struct struct_7 {    uint8_t a;    uint16_t b;    uint32_t c;};printf("struct_4 size: %d\n", sizeof(struct struct_4));  // struct_4 size: 8printf("struct_5 size: %d\n", sizeof(struct struct_5));  // struct_5 size: 7printf("struct_6 size: %d\n", sizeof(struct struct_6));  // struct_6 size: 7printf("struct_7 size: %d\n", sizeof(struct struct_7));  // struct_7 size: 8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>按照默认的对齐规则，结构体的大小为4字节。</li><li>使用伪指令设置对齐值为1后，结构体的大小为4字节，且影响了后续所有结构体的对齐值。</li><li>若手动设置的对齐值比结构体中所有的成员都大，则根据字节对齐原则，相当于无效设置。</li></ul><h2 id="使用C关键字"><a href="#使用C关键字" class="headerlink" title="使用C关键字"></a>使用C关键字</h2><ul><li>使用<code>__attribute((aligned(n)))</code>，可以指定单个结构体的对齐值（不确保一定生效）。</li><li>使用<code>__attribute((packed))</code>，可以取消单个结构体在编译过程中的优化对齐，即取消字节对齐。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工作学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 编程问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++实现读写WAV音频文件</title>
      <link href="/2023/10/13/c-c-shi-xian-du-xie-wav-yin-pin-wen-jian/"/>
      <url>/2023/10/13/c-c-shi-xian-du-xie-wav-yin-pin-wen-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="C-C-实现读写WAV音频文件"><a href="#C-C-实现读写WAV音频文件" class="headerlink" title="C/C++实现读写WAV音频文件"></a>C/C++实现读写WAV音频文件</h1><p>WAV音频文件本质上是一个二进制文件，C语言可通过fopen读写二进制文件的方法读写WAV音频文件。但WAV文件内不仅存储了音频的数据，还存储的文件信息，因此若要获取正确的WAV文件内容，需要知道WAV存储的的格式，按照WAV格式进行读写操作。</p><h2 id="WAV格式文件"><a href="#WAV格式文件" class="headerlink" title="WAV格式文件"></a>WAV格式文件</h2><p>WAV（Waveform Audio File Format）是一种常见的音频文件格式，它通常用于存储未经压缩的音频数据。WAV文件遵循RIFF规则，其内容以区块为最小单位进行存储。WAV文件一般由3个区块组成：RIFF区块、Format区块和Data区块。</p><h2 id="RIFF区块"><a href="#RIFF区块" class="headerlink" title="RIFF区块"></a>RIFF区块</h2><table><thead><tr><th>名称</th><th>偏移地址</th><th>字节数</th><th>数据类型</th><th>端序</th><th>内容</th></tr></thead><tbody><tr><td>chunkID</td><td>0x00</td><td>4</td><td>char</td><td>大端</td><td>“RIFF”</td></tr><tr><td>chunkSize</td><td>0x04</td><td>4</td><td>uint32_t</td><td>小端</td><td>文件长度</td></tr><tr><td>format</td><td>0x08</td><td>4</td><td>char</td><td>大端</td><td>“WAVE”</td></tr></tbody></table><h2 id="Format区块"><a href="#Format区块" class="headerlink" title="Format区块"></a>Format区块</h2><table><thead><tr><th>名称</th><th>偏移地址</th><th>字节数</th><th>数据类型</th><th>端序</th><th>内容</th></tr></thead><tbody><tr><td>subchunk1ID</td><td>0x0C</td><td>4</td><td>char</td><td>大端</td><td>“fmt”，fmt标识</td></tr><tr><td>audioFormat</td><td>0x10</td><td>4</td><td>uint32_t</td><td>小端</td><td>子块大小，通常为16</td></tr><tr><td>audioFormat</td><td>0x14</td><td>2</td><td>uint16_t</td><td>小端</td><td>音频格式代码，1表示PCM无损编码</td></tr><tr><td>numChannels</td><td>0x16</td><td>2</td><td>uint16_t</td><td>小端</td><td>声道数，通常为1（单声道）或2（立体声）</td></tr><tr><td>sampleRate</td><td>0x18</td><td>2</td><td>uint16_t</td><td>小端</td><td>采样率，表示每秒的采样数</td></tr><tr><td>byteRate</td><td>0x1C</td><td>4</td><td>uint32_t</td><td>小端</td><td>每秒的字节数，等于<code>sampleRate</code> * <code>numChannels</code> * (<code>bitsPerSample</code> / 8)</td></tr><tr><td>blockAlign</td><td>0x20</td><td>2</td><td>uint16_t</td><td>小端</td><td>块对齐，等于<code>numChannels</code> * (<code>bitsPerSample</code> / 8)</td></tr><tr><td>bitsPerSample</td><td>0x22</td><td>2</td><td>uint16_t</td><td>小端</td><td>每个样本的位深度，通常为8、16、24或32</td></tr></tbody></table><h2 id="Data区块"><a href="#Data区块" class="headerlink" title="Data区块"></a>Data区块</h2><table><thead><tr><th>名称</th><th>偏移地址</th><th>字节数</th><th>数据类型</th><th>端序</th><th>内容</th></tr></thead><tbody><tr><td>subchunk2ID</td><td>0x24</td><td>4</td><td>char</td><td>大端</td><td>子块标识，通常为”data”</td></tr><tr><td>subchunk2Size</td><td>0x28</td><td>4</td><td>uint32_t</td><td>小端</td><td>音频数据大小，等于采样数 * <code>numChannels</code> * (<code>bitsPerSample</code> / 8)</td></tr><tr><td>data</td><td>0x2C</td><td></td><td></td><td></td><td>数据</td></tr></tbody></table><blockquote><p><code>uint16_t</code> 和 <code>uint32_t</code> 是无符号整数类型的数据类型，它们是C/C++ &lt;stdint.h&gt;标准库中定义的确切位数的整数类型.**<code>uint16_t</code><strong>：这是一个16位无符号整数类型，确保有16位位数，没有符号位。</strong><code>uint32_t</code>**：这是一个32位无符号整数类型，确保有32位位数，没有符号位。</p></blockquote><h1 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h1><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;// 定义WAV文件头部结构struct WAVHeader {    char chunkID[4];        // 文件标识，通常为"RIFF"    uint32_t chunkSize;     // 文件大小    char format[4];         // 文件格式，“WAVE”    char subchunk1ID[4];    // 子块标识，“fmt”    uint32_t subchunk1Size; // 子块大小    uint16_t audioFormat;   // 音频格式，1为PCM格式    uint16_t numChannels;   // 声道数，1:单声道，2:双声道    uint32_t sampleRate;    // 采样率    uint32_t byteRate;      // 每秒的字节数    uint16_t blockAlign;    // 块对齐    uint16_t bitsPerSample; // 采样深度    char subchunk2ID[4];    // 子块标识，“data”    uint32_t subchunk2Size; // 子块大小};// 音频数据结构struct WAVData {    struct WAVHeader header;  // 音频头部数据    uint8_t* sample;          // 音频数据};// 读取wav格式文件struct WAVData* audioread(const char* filename);// 写入wav格式文件void audiowrite(const char* filename, struct WAVData* audio_data);int main() {    char filename[30] = "../inputs/test.wav";    struct WAVData* audio_data = audioread(filename);    if (audio_data == NULL) {        perror("文件打开失败!");        return 1;    }    char outfilename[30] = "../outputs/test.wav";    audiowrite(outfilename, audio_data);    return 0;}struct WAVData* audioread(const char* filename) {    // 打开文件    FILE* inputFile = fopen(filename, "rb");    struct WAVData* audio_data = NULL;    if (inputFile == NULL) {        perror("文件代开失败!");        return NULL;    }    // 读取文件头部信息    struct WAVHeader header;    fread(&amp;header, sizeof(struct WAVHeader), 1, inputFile);    // 验证文件格式    if (strncmp(header.chunkID, "RIFF", 4) != 0 || strncmp(header.format, "WAVE", 4) != 0) {        perror("无效文件!");        fclose(inputFile);        return NULL;    }    // 输出wav文件信息    printf("音频格式: %hu\n", header.audioFormat);    printf("声道数: %hu\n", header.numChannels);    printf("采样率: %hu\n", header.sampleRate);    printf("采样深度: %hu\n", header.bitsPerSample);    // 读取wav文件数据    audio_data = (struct WAVData*)malloc(sizeof(struct WAVData));    if (audio_data == NULL) {        perror("内存申请失败!");        return NULL;    }    audio_data-&gt;header = header;    audio_data-&gt;sample = (uint8_t*)malloc(header.subchunk2Size);    if (audio_data-&gt;sample == NULL) {        perror("内存申请失败!");        free(audio_data);        return NULL;    }    fread(audio_data-&gt;sample, header.subchunk2Size, 1, inputFile);    fclose(inputFile);    return audio_data;}void audiowrite(const char* filename, struct WAVData* audio_data) {    // 打开输出文件    FILE* outputFile = fopen(filename, "wb");    if (outputFile == NULL) {        perror("文件打开失败!");        return;    }    // 写入文件    fwrite(&amp;audio_data-&gt;header, sizeof(struct WAVHeader), 1, outputFile);    fwrite(audio_data-&gt;sample, audio_data-&gt;header.subchunk2Size, 1, outputFile);    // 关闭文件    fclose(outputFile);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>源码地址：<a href="https://github.com/lyc18/C-CPP-read-write-WAV">https://github.com/lyc18/C-CPP-read-write-WAV</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工作学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 编程实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/10/03/hello-world/"/>
      <url>/2023/10/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
